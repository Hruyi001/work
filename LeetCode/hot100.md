### 1. 两数之和[**](https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) { 
        unordered_map<int,int> mp; 
        for(int i = 0; i < nums.size(); i++) {
            if(mp.count(target - nums[i])) 
                return {mp[target - nums[i]], i};
            mp[nums[i]] = i;
        }
        return {-1, -1};
    }
};
```   
### 2. 字母异位词分组[**](https://leetcode.cn/problems/group-anagrams/submissions/494409922/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> p;
        for(auto s : strs) {
            string t = s;
            sort(s.begin(), s.end());
            p[s].push_back(t);
        }
        vector<vector<string>> res;
        for(auto item : p) 
            res.push_back(item.second);
        return res;
    }
};
```
### 3. 最长连续序列[*****](https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) { 
        unordered_set<int> st;
        for(auto x : nums) st.insert(x);
        int res = 0;
        for(auto x : nums) {
            // 挑选可以作为首个元素的位置，去查找
            if(!st.count(x - 1)) {
                int y = x; 
                while(st.count(y)) {
                    // 遍历完就删除，防止被重复使用，使得复杂度n*n
                    st.erase(y);
                    y++; 
                }
                res = max(res, y - x);
            }
        }
        return res;
    }
};
```
### 4. 移动零[*](https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size();
        int k = 0;
        for(int i  = 0; i < n; i++)
            if(nums[i]) nums[k++] = nums[i];
        while(k < n) nums[k++] = 0;
        
    }
};
```
### 5. 盛水最多的容器[*****](https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    // 贪心做法
    int maxArea(vector<int>& height) {
        int res = 0, n = height.size();
        // 双指针，从左往右找到左端点，从右往左找到右端点
        for(int i = 0, j = n - 1;  i　< j; ) {
            res = max(res, (j - i ) * min(height[i], height[j]));
            // 随着j-i的缩小，只有两端高度的最小值变大，才能让区域面积变大
            if(height[i] < height[j]) i++;
            else j--;
        }
        return res;
    }
};
```
### 6. 三数之和[*****](https://leetcode-cn.com/problems/3sum/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> v;
        int n = nums.size();
        for(int i = 0; i < n; i++) {
            if(i && nums[i] == nums[i - 1]) continue;
            for(int j = i + 1, k = n - 1; j < k; j++) {
                if(j > i + 1 && nums[j] == nums[j - 1]) continue;
                while(j < k - 1 && nums[i] + nums[j] + nums[k - 1] >= 0) k--;
                if(nums[i] + nums[j] + nums[k] == 0) v.push_back({nums[i], nums[j] , nums[k]});
            }
        }
        return v;
    }
};
```
### 7. 接雨水[*****](https://leetcode.cn/problems/trapping-rain-water/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    // 分别向左和向右扫描并记录左边和右边的最大高度，然后计算每个下标位置能接的雨水量。假设数组height的长度为n，该做法需要对每个下标位置使用O(n)的时间向两边扫描并得到最大高度 
    int trap(vector<int>& height) {
        int n = height.size();
        vector<int> l(n + 1), r(n + 1); 
        l[0] = height[0];
        for(int i = 1; i < n; i++) l[i] = max(l[i - 1], height[i]);
        r[n - 1] = height[n - 1]; 
        for(int i = n - 2; ~i; i--)  r[i] = max(r[i + 1], height[i]);
        int res = 0;
        for(int i = 0; i < n; i++) 
            res +=  min(l[i], r[i]) - height[i];
        return res;
    }
};
```
### 8. 无重复字符的最长子串[***](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char,int> mp;
        int res = 0;
        for(int i = 0, j = 0; i < s.size(); i++) {
            // 窗口右指针向右移
            mp[s[i]]++;
            // 窗口左指针移
            while(mp[s[i]] > 1) mp[s[j++]]--;
            res = max(res, i - j + 1);
        }
        return res;
    }
};
```
### 9. 找到字符串中所有字母异位词[****](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        unordered_map<int,int> mp;
        // p中的字符出现次数
        for(auto c : p) mp[c]++;
        vector<int> res;
        int n = mp.size(), sort = 0;
        for(int i = 0, j = 0; i < s.size(); i++) {
            // s[j]这类字符在p中出现次数为0，类别加1
            if(--mp[s[i]] == 0) sort++;
            // 窗口大小等于p.size()时，左指针移动
            while(i - j + 1 > p.size()) {
                if(mp[s[j]] == 0) sort--;
                mp[s[j++]]++;
            }
            if(sort == n) res.push_back(j);
        }
        return res;
    }
};
``` 
### 10. 和为k的子数组[****](https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
// 字符串+哈希
    int subarraySum(vector<int>& nums, int k) { 
         int n = nums.size();
         vector<int> s(n + 1);
         for(int i = 1; i <=n ; i++) s[i] = s[i - 1] + nums[i - 1];
         unordered_map<int,int> mp;
         int res = 0;
         mp[0] = 1;
         for(int i = 1; i <= n; i++) {
            res += mp[s[i] - k];
            mp[s[i]]++;
         }
         return res;
    }
};
```
### 11. 滑动窗口最大值[]()
```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> q(n), v;
        int hh = 0, tt = -1;
        for(int i = 0; i < nums.size(); i++) {
            // 窗口不能超过k
            while(hh <= tt && i - q[hh] >= k) hh++;
            // 保持单调递减
            while(hh <= tt && nums[q[tt]] <= nums[i]) tt--;
            q[++tt] = i;
            if(i >= k - 1) v.push_back(nums[q[hh]]);
        }
        return v;
    }
};
```
### 12. 最小覆盖字串[*****](https://leetcode.cn/problems/minimum-window-substring/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    string minWindow(string s, string t) { 
        unordered_map<int,int> ht, wd;
        for(auto x : t) ht[x]++;
        int cnt = 0;
        string res;
        for(int i = 0, j = 0; i < s.size(); i++) {
            if(++wd[s[i]] <= ht[s[i]])  
                cnt++;
            while(wd[s[j]] > ht[s[j]]) {
                // 这是去掉多余的，与cnt无关
                wd[s[j++]]--; 
            }
            if(cnt == t.size()) { 
                if(res.empty() || res.size() > i - j + 1) 
                    res = s.substr(j, i - j + 1);
            }
        }
        return res;
    }
};
```
### 13. 最大子数组和[***](https://leetcode.cn/problems/maximum-subarray/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int sum = nums[0], res = nums[0];
        for(int i = 1; i < nums.size(); i++) {
            sum = max(0, sum ) + nums[i];
            res = max(res, sum);
        }
        return res;
    }
};
```
### 14. 区间合并[****](https://leetcode.cn/problems/merge-intervals/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        // 先按照左端点排序，再按照右端点排序
         sort(intervals.begin(), intervals.end());
         int l = intervals[0][0], r = intervals[0][1];
         vector<vector<int>> res;
         for(int i = 1; i < intervals.size(); i++) {
            if(intervals[i][0] > r) {
                // 区间无重叠
                res.push_back({l, r});
                l = intervals[i][0], r = intervals[i][1];
            }
            else 
                // 区间重叠，更新区间右端点
                r = max(r, intervals[i][1]);
         }
         res.push_back({l, r});
         return res;
    }
};
```
### 15. 轮转数组[**](https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    void order(vector<int>& nums, int l, int r) {
        for(int i = l, j = r; i < j; i++, j--) {
            int tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
        }
    }
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k %= n;
        order(nums, 0, n - k - 1);
        order(nums, n - k, n - 1);
        order(nums, 0, n - 1);
    }
};
```
### 16. 除自身以外数组的乘积[***](https://leetcode.cn/problems/product-of-array-except-self/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> v(n, 1);
        for(int i = 1; i < n; i++) 
            v[i] = v[i - 1] * nums[i - 1];
        int s = 1;
        for(int i = n - 1; ~i; i--) { 
            v[i] *= s;
            s *= nums[i];
        }
        return v;
    }
};
```
### 17. 缺失的第一个正数[]()
```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for(auto &x : nums) 
            if(x != INT_MIN) x--;
        for(int i = 0; i < nums.size(); i++) {
            while(nums[i] >= 0 && nums[i] <= n - 1 && nums[i] != nums[nums[i]]) 
                swap(nums[i], nums[nums[i]]);
        }
        for(int i = 0; i < n; i++)
            if(i != nums[i]) 
                return i + 1;
        return n + 1;
    }
};
```
### 18. 矩阵置零[*****](https://leetcode.cn/problems/set-matrix-zeroes/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int row = 0, col = 0;
        int n = matrix.size();
        if(!n) return;
        int  m = matrix[0].size();
        for(int i = 0; i < m; i++)
            if(!matrix[0][i]) {
                row = 1;
                // matrix[0][i] = 1;
            }

        for(int i = 0; i < n; i++) 
            if(!matrix[i][0]) {
                col = 1;
                // matrix[i][0] = 1;
            }

        for(int i = 1; i < n; i++)
        for(int j = 1; j < m; j++)
        if(!matrix[i][j]) 
        {
            matrix[i][0] = matrix[0][j] = 0;
        }
        for(int i = 1; i < n; i++)
            if(!matrix[i][0])
                for(int j  =1 ; j < m; j++)
                    matrix[i][j] = 0;
        for(int i = 1; i < m; i++)
            if(!matrix[0][i]) 
                for(int j = 1; j < n; j++)
                    matrix[j][i] = 0;
        if(row) 
            for(int i = 0; i < m; i++) matrix[0][i] = 0;

        if(col)
            for(int i = 0; i < n; i++) matrix[i][0] = 0;

    }
};
```
### 19. 螺旋矩阵[*****](https://leetcode.cn/problems/spiral-matrix/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    int dr[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> v;
        int n = matrix.size();
        if(!n) return v;
        int m = matrix[0].size();
        vector<vector<bool>> st(n + 1, vector<bool>(m + 1, 0));
        int i = 0, j = 0, d = 0;
        for(int k = 1; k <= m * n; k++) {
            st[i][j] = 1;
            v.push_back(matrix[i][j]);
            int u = i + dr[d][0], v = j + dr[d][1];
            if(u < 0 || u >= n || v < 0 || v >=m || st[u][v]) {
                d = (d +  1) % 4;
                u = i + dr[d][0], v = j + dr[d][1];
            }
            i = u, j = v;
        }
        return v;
    }
};
```
### 20. 旋转图像[***](https://leetcode.cn/problems/rotate-image/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        for(int i = 0; i < matrix.size(); i++)
        for(int j = 0; j < i; j++)
            swap(matrix[i][j], matrix[j][i]);
        for(int i = 0; i < matrix.size(); i++)
        for(int j = 0, k = matrix[i].size() - 1; j < k; j++, k--)
            swap(matrix[i][j], matrix[i][k]);
        
    }
};
```
### 21. 搜索二维矩阵[****](https://leetcode.cn/problems/search-a-2d-matrix-ii/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if(matrix.empty() || matrix[0].empty()) return false;
        int n = matrix.size(), m = matrix[0].size();
        int i = 0, j = m - 1;
        while(i < n && j >= 0) {
            if(matrix[i][j] > target) j--;
            else if(matrix[i][j] < target) i++;
            else return true;
        }
        return false;
    }
};
```
### 22. 相交链表[***](https://leetcode.cn/problems/search-a-2d-matrix-ii/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {  
        ListNode *p = headA, *q = headB;
        while(p != q) {
            if(p == NULL) p = headB;
            else p = p->next;
            if(q == NULL) q = headA;
            else q = q->next;
        }
        return p;
    }
};
```
### 23. 反转链表[**](https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *pre = new ListNode();
        ListNode *p = head;
        while(p) {
            ListNode *q = p->next;
            p->next = pre->next;
            pre->next = p;
            p = q;
        }
        return pre->next;
    }
};
```
### 24. 回文链表[*****](https://leetcode.cn/problems/palindrome-linked-list/description/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode *head) {
        ListNode *pre = new ListNode();
        ListNode *p = head, *q;
        while(p) {
            q = p->next;
            p->next = pre->next;
            pre->next = p;
            p = q;
        }
        return pre->next;
    }
    ListNode* getMid(ListNode *head) {
        ListNode *p = head, *q = head;
        // x + 1
        // 2 *x + 2
        // 2 * x + 3
        while(q->next && q->next->next) {
            p = p->next;
            q = q->next->next;
        }
        return p;
    }
    bool isPalindrome(ListNode* head) {
        ListNode *mid = getMid(head);
        ListNode *p = head, *q = reverseList(mid->next);
        mid->next = NULL;
        while(p && q) {
            if(p->val != q->val) return false;
            p = p->next;
            q  = q->next;
        }
        return true;
    }
};
```
### 25. 环形链表[***](https://leetcode-cn.com/problems/linked-list-cycle/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode *p = head, *q = head;
        while(q && q->next) { 
            p = p->next;
            q = q->next->next;
            if(p == q) return true;
        }
        return false;
    }
};
```
### 26. 环形链表2[*****](https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {  
        ListNode *p = head, *q = head;
        while(q && q->next) {
            p = p->next; 
            q = q->next->next;
            if(p == q) {
                p = head;
                while(p != q) {
                    p = p->next;
                    q = q->next;
                }
                return p;
            }
        }
        return NULL;
    }
};
```
### 27. 合并两个有序链表[***](https://leetcode.cn/problems/merge-two-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution{
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {   
        ListNode *pre = new ListNode();
        ListNode *p = list1, *q = list2, *r = pre;
        while(p && q) {
            if(p->val < q->val) {
                r->next = p;
                p = p->next;
            }
            else {
                r->next = q;
                q = q->next;
            }
            r = r->next;
        }
        if(p) r->next = p;
        else r->next = q;
        return pre->next;
    }
};
```
### 28. 两数相加[***](https://leetcode.cn/problems/add-two-numbers/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *pre = new ListNode();
        ListNode *p = l1, *q = l2,  *r = pre;
        int t = 0;
        while(p || q || t) {
            int a = p ? p->val : 0;
            int b = q ? q->val : 0;
            if(p) p = p->next;
            if(q) q = q->next;
            t += a + b;
            r->next = new ListNode(t % 10);
            r = r->next;
            t /= 10; 
        }
        return pre->next;
    }
};
```
### 29. 删除链表的倒数第N个节点[***](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *pre = new ListNode();
        pre->next = head;
        ListNode *p = pre, *q = pre;
        for(int i = 0; i < n; i++) p = p->next;
        while(p->next) {
            p = p->next;
            q = q->next;
        }
        q->next = q->next->next;
        return pre->next;
    }
};
```
### 30. 两两交换链表中的节点[****](https://leetcode.cn/problems/swap-nodes-in-pairs/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head || !head->next) return head;
        ListNode *p = head->next;
        head->next = swapPairs(p->next);
        p->next = head;
        return p;
    }
};
```
### 31. k个一组翻转链表[*****](https://leetcode.cn/problems/reverse-nodes-in-k-group/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        int n = 0;
        for(ListNode *p = head; p; p = p->next) n++;
        int a = n / k;
        ListNode *pre = new ListNode(); 
        ListNode *r = pre, *p = head;
        for(int i = 0; i < a; i++) {
            ListNode *t = p;
            for(int j = 0; j < k; j++) {
                ListNode *q = p->next;
                p->next = r->next;
                r->next = p;
                p = q;
            }
            r = t;
        }
        r->next = p;
        return pre->next;
    }
};
```
### 32. 随机链表的复制[]()
```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head) { 
        if(!head) return NULL;
        for(Node *p = head; p; p = p->next->next) {
            Node *q = p->next;
            p->next = new Node(p->val);
            p->next->next = q; 
        }
        for(Node *p = head; p; p = p->next->next) 
            p->next->random = p->random ? p->random->next : NULL;
        
        Node *pre = head->next;
        for(Node *p = head; p; p = p->next) {
            Node *q = p->next;
            p->next = p->next->next;
            q->next = q->next ? q->next->next : NULL;
        }
        return pre; 
    }
};
```
### 33. 排序链表[*****](https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&envId=top-100-liked)
方法一：非递归：时间复杂度nlogn,空间复杂度O(1)
```c++ 
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public: 
    ListNode* sortList(ListNode* head) { 
        int  n = 0;
        for(ListNode *p = head; p; p = p->next) n++; 
        // 自底向上归并排序，进行logn层归并
        for(int i = 1; i < n; i *= 2) {
            // 将head作为旧的链表，pre新的归并链表
            ListNode *pre = new ListNode();
            ListNode *p = head, *q = p, *u = pre;
            // //把1~n划分成包含2个长度i段，对这2个长度为i的区间进行归并，每一层，各个分治区间进行归并
            for(int j = 1; j <=n; j += 2 * i) { 
                
                q = p;
                for(int k = 0; k < i && q; k++) q = q->next;
                int l = 0, r = 0;
                //  p是左区间起始位置，q是右区间起始位置， 还要限制区间长度范围内
                while(l < i && r < i && p && q) {
                    if(p->val < q->val) {
                        u->next = p;
                        p = p->next;
                        l++;
                    }
                    else {
                        u->next = q;
                        q = q->next;
                        r++;
                    }
                    u = u->next;
                } 
                while(l < i && p) {
                    u->next = p;
                    u = u->next;
                    p = p->next;
                    l++;
                }
                while(r < i && q) {
                    u->next = q;
                    u = u->next;
                    q = q->next;
                    r++;
                }
                // 迭代到下一个归并区间起始位置
                p = q; 
            }
            // 尾节点后要为空
            u->next = NULL;
            head = pre->next;
        }
        return head;
    }
};
```
方法二：递归：时间复杂度nlogn,空间复杂度O(logn)
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode *getMid(ListNode* head, ListNode *tail) {
        ListNode *p = head, *q = head;
        while(q != tail && q->next != tail) {
            p = p->next;
            q = q->next->next;
        }
        return p;
    }
    ListNode *mergeTwo(ListNode *l1, ListNode *l2) {
        ListNode *pre = new ListNode();
        ListNode *p = l1, *q = l2, *r = pre;
        while(p && q) {
            if(p->val < q->val) {
                r->next = p;
                p = p->next;
            }
            else {
                r->next = q;
                q = q->next;
            }
            r = r->next;
        }
        r->next = p ? p : q;
        return pre->next;
    }
    ListNode *merge(ListNode *head, ListNode *tail) {
        if(head == tail) return nullptr;
        if(head->next == tail) {
            head->next = nullptr;
            return head;
        }
        ListNode *mid = getMid(head, tail); 
        ListNode *left = merge(head, mid);
        ListNode *right = merge(mid, tail);
        return mergeTwo(left, right);
    }
    ListNode* sortList(ListNode* head) {
        return merge(head, nullptr);
    }
};
```
### 34. 合并k个升序链表[*****](https://leetcode.cn/problems/merge-k-sorted-lists/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwo(ListNode *l1, ListNode *l2) {
        ListNode *p = l1, *q = l2, *pre = new ListNode(), *r = pre;
        while(p && q) {
            if(p->val < q->val) {
                r->next = p;
                p = p->next;
            }
            else {
                r->next = q;
                q = q->next;
            }
            r = r->next;
        }
        if(p) r->next = p;
        else r->next = q;
        return pre->next;
    }
    ListNode *merge(vector<ListNode*>& lists, int l, int r) {
        if(l > r) return NULL;
        if(l == r) return lists[l];
        int mid = l + r >> 1;
        ListNode *left = merge(lists, l, mid), *right = merge(lists, mid + 1, r);
        return mergeTwo(left, right);
    }
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        int n = lists.size();
        return merge(lists, 0,  n - 1);
    }
};
```
### 35. LRU缓存[*****](n/problems/lru-cache/?envType=study-plan-v2&envId=top-100-liked)
```c++
class LRUCache {
public: 
    // 缓存存储的是键值对，要有key，通过key找到哈希位置（删除最久的节点使用）
    struct Node{
        int key, val;
        Node *left, *right;
        Node(){}
        Node(int x, int y):key(x), val(y), left(NULL), right(NULL){}
    }*L, *R;
    unordered_map<int, Node*> mp;
    int n;
    LRUCache(int capacity) {  
        n = capacity;
        L = new Node(-1, -1), R = new Node(-1, -1);
        L->right = R;
        R->left = L;
    }  
    // 在L后插入节点，需要四行
    void insert(Node *p) {
        // 这里注意
        L->right->left = p;
        p->right = L->right;
        p->left = L;  
        L->right = p; 
    }
    // 删除节点
    void remove(Node *p) {
        p->left->right = p->right;
        p->right->left = p->left;
    }
    // 获取节点时，更新最近节点
    int get(int key) { 
        if(mp.count(key)) {
            Node *p = mp[key];
            remove(p);
            insert(p);
            return p->val;
        }
        return -1;
    }
    
    void put(int key, int value) { 
        // 缓存中存在这个key。要更新缓存和哈希表
        if(mp.count(key)) {
            Node *p = mp[key];
            p->val = value;
            remove(p);
            insert(p);
            mp[key] = p;
        }
        else {
            // 缓存已满，从缓存和哈希表删除最久的节点
            if(mp.size() == n) {
                Node *p = R->left;
                remove(p); 
                mp.erase(p->key);
                // 放在最后一步
                delete(p);
            }
            // 插入最新的节点
            Node *r = new Node(key, value);
            insert(r);
            mp[key] = r;
        }
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
 ```
### 36. 二叉树的中序遍历[***](https://leetcode.cn/problems/binary-tree-inorder-traversal/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {  
        vector<int> v;
        if(!root) return v;
        stack<TreeNode*> stk;
        TreeNode *p = root;
        while(stk.size() || p) {
            // 把最左边的节点沿路都添加进去
            while(p) {
                stk.push(p);
                p = p->left;
            }
            p = stk.top();
            stk.pop();
            v.push_back(p->val);
            p = p->right;
        }
        return v;
    }
};
```
### 37. 二叉树的最大深度[**](https://leetcode.cn/problems/maximum-depth-of-binary-tree/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```
### 38. 翻转二叉树[**](https://leetcode.cn/problems/invert-binary-tree/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) { 
        if(!root) return NULL;
        auto l = invertTree(root->left), r = invertTree(root->right);
        root->left = r;
        root->right = l;
        return root;
    }
};
```
### 39. 对称二叉树[***](https://leetcode.cn/problems/symmetric-tree/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public: 
    bool dfs(TreeNode *p, TreeNode *q) {
        if(!p && !q) return true;
        if(!p || !q) return false;
        return p->val == q->val && dfs(p->left, q->right) && dfs(p->right, q->left);
    }
    bool isSymmetric(TreeNode* root) { 
        if(!root) return true;
        return dfs(root->left, root->right);
    }
};
```
### 40. 二叉树的直径[***](https://leetcode.cn/problems/diameter-of-binary-tree/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int res;
    int dfs(TreeNode *root) {
        if(!root) return 0;
        int left = dfs(root->left),  right = dfs(root->right);
        res = max(res, left + right + 1);
        return max(left, right) + 1;
    }
    int diameterOfBinaryTree(TreeNode* root) {
        dfs(root);
        return res - 1;
    }
};
```
### 41. 二叉树的层序遍历[***](https://leetcode.cn/problems/binary-tree-level-order-traversal/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> q;
        vector<vector<int>> v;
        if(!root) return v;
        q.push(root);
        while(q.size()) {
             int n = q.size();
             vector<int> res;
             for(int i = 0; i < n; i++) {
                auto t = q.front();
                q.pop();
                res.push_back(t->val);
                if(t->left) q.push(t->left);
                if(t->right) q.push(t->right);
             }
             v.push_back(res);
        }
        return v;
    }
};
```
### 42. 将有序数组转换为二叉搜索树[****](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public: 
    TreeNode* merge(vector<int>& nums, int l, int r) {
        if(l > r) return NULL;
        if(l == r) {
            TreeNode* root = new TreeNode(nums[l]);
            return root;
        } 
        int mid = l + r >> 1;
        TreeNode *root = new TreeNode(nums[mid]);
        root->left = merge(nums, l,  mid - 1);
        root->right = merge(nums, mid + 1, r);
        return root;
    }
    
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return merge(nums, 0, nums.size() - 1);
    }
};
```
### 43. 验证二叉搜索树[*****](https://leetcode.cn/problems/validate-binary-search-tree/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution { 
    public:
    bool dfs(TreeNode *root, long minVal, long maxVal) {
        if(!root) return true;
        if(root->val < minVal || root->val > maxVal) return false;
        return dfs(root->left, minVal, root->val) && dfs(root->right, root->val, maxVal);
    }
    bool isValidBST(TreeNode* root) { 
        return dfs(root, LONG_MIN, LONG_MAX);
    }
};
```
### 44. 二叉搜索树中第 K 小的元素[**](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int k, res;
    void dfs(TreeNode *root) {
        if(!root) return;
        dfs(root->left);
        k--;
        if(!k) {
            res = root->val;
            return;
        }
        if(k) dfs(root->right);
    }
    int kthSmallest(TreeNode* root, int _k) {
        k = _k;
        dfs(root);
        return res;
    }
};
```
### 45. 二叉树的右视图[**](https://leetcode.cn/problems/binary-tree-right-side-view/description/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> v;
        if(!root) return v;
        queue<TreeNode*> q;
        q.push(root);
        while(q.size()) {
            int n = q.size();
            for(int i = 0; i < n; i++) {
                auto t = q.front();
                if(i == n - 1) v.push_back(t->val);
                q.pop();
                if(t->left) q.push(t->left);
                if(t->right) q.push(t->right);
            }
        }
        return v;
    }
};
```
### 46. 二叉树展开为链表[*****](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void flatten(TreeNode* root) { 
        while(root) { 
            // 判断左子树为是否空
            if(root->left) {
                TreeNode *p = root->left; 
                // 找到左子树中最右边的节点
                while(p->right) {
                    p = p->right;
                }
                // 将这个节点插入在根和右子树之间
                p->right = root->right;
                // 将根的左子树插入根的右边
                root->right = root->left;
                // 根的左节点置空
                root->left = NULL;
            }
            // 向右遍历
            root = root->right;
        }
    }
};
```
### 47. 从前序与中序遍历序列构造二叉树[*****](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    unordered_map<int,int> mp;
    TreeNode* build(vector<int>& pre, vector<int>& in, int pl, int pr, int il, int ir) {
        if(il > ir) return NULL;
        TreeNode *root = new TreeNode(pre[pl]);
        int index = mp[pre[pl]];
        root->left = build(pre, in, pl + 1, pl + (index - il), il, index - 1);
        root->right = build(pre, in, pl + (index - il) + 1, pr, index + 1, ir);
        return root;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = inorder.size();
        for(int i = 0; i < n; i++) 
            mp[inorder[i]] = i;
        return build(preorder, inorder, 0, n - 1, 0, n - 1);
    }
};
```
### 48.路径总和III[***](https://leetcode.cn/problems/path-sum-iii/description/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public: 
    // 前缀和+哈希，Key是Long级别
    unordered_map<long,int> mp;
    int res;
    // 先序遍历，从父节点到子节点
    void dfs(TreeNode* root, long sum, int targetSum) {
        if(!root) return;
        sum += root->val;
        // 沿路经过的路径和为targetSum的路径数
        res += mp[sum - targetSum];
        // 保存前缀和
        mp[sum]++;
        dfs(root->left, sum, targetSum);
        dfs(root->right, sum, targetSum); 
        //  恢复现场
        mp[sum]--;
    }
    int pathSum(TreeNode* root, int targetSum) { 
        mp[0] = 1;
        dfs(root, 0, targetSum);
        return res;
    }
};
```
### 49. 二叉树的最近公共祖先[*****](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode *res;
    bool dfs(TreeNode *root, TreeNode *p, TreeNode *q) {
        if(!root) return false;
        auto left = dfs(root->left, p,  q);
        auto right = dfs(root->right, p, q);
        if(left && right || (root->val == p->val || root->val == q->val) && (left || right)) { 
            res = root;
            return true;
        }
        return (p->val == root->val) || (q->val == root->val) || left  || right;
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        dfs(root, p, q);
        return res;
    }
};
```
### 50. 二叉树中的最大路径和[*****](https://leetcode.cn/problems/binary-tree-maximum-path-sum/?envType=study-plan-v2&envId=top-100-liked)
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int res = INT_MIN;
    int dfs(TreeNode *root) {
        if(!root) return 0;
        int left = max(0, dfs(root->left)), right = max(0, dfs(root->right));
        res = max(res, left + right + root->val);
        return max(left, right) + root->val;
    }
    int maxPathSum(TreeNode* root) {
        dfs(root);
        return res;
    }
};
```
### 51. 岛屿数量[***](https://leetcode.cn/problems/number-of-islands/description/?envType=study-plan-v2&envId=top-100-liked)
方法一：dfs
```c++
class Solution {
public:
    int n, m;
    int dr[4][2] = {{1,0}, {-1,0}, {0,1},{0,-1}};
    void dfs(vector<vector<char>>& grid, int x, int y) {
       grid[x][y] = '2';
       for(int i = 0; i < 4; i++) 
        {
            int a = x + dr[i][0], b = y + dr[i][1];
            if(a < 0 || a >= n || b < 0|| b >= m || grid[a][b] != '1') continue;
            dfs(grid, a, b);
        }
    }
    int numIslands(vector<vector<char>>& grid) {
        if(grid.empty() || grid[0].empty()) return 0;
        n = grid.size(), m = grid[0].size();
        int res = 0;
        for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            if(grid[i][j] == '1') {
                dfs(grid, i, j);
                res++;
            }
        return res;
    }
};
```
方法二：bfs
```c++
class Solution {
public:
    int n, m;
    int dr[4][2] = {{1,0}, {-1,0}, {0,1},{0,-1}};
    void bfs(vector<vector<char>>& grid, int x, int y) {
        queue<pair<int,int>> q;
        q.push({x,y});
        grid[x][y] = '2';
        while(q.size()) {
            auto t = q.front();
            q.pop();
            int u = t.first, v = t.second;
            
            for(int i = 0; i < 4; i++) {
                int a = u + dr[i][0], b = v + dr[i][1];
                if(a < 0 || a >= n || b < 0 || b >= m || grid[a][b] != '1') continue;
                grid[a][b] = '2';
                q.push({a,b});
            }
        }
    }
    int numIslands(vector<vector<char>>& grid) {
        if(grid.empty() || grid[0].empty()) return 0;
        n = grid.size(), m = grid[0].size();
        int res = 0;
        for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            if(grid[i][j] == '1') {
                bfs(grid, i, j);
                res++;
            }
        return res;
    }
};
```
### 52. 腐烂的橘子[****](https://leetcode.cn/problems/rotting-oranges/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    int dr[4][2] = {{1, 0}, {-1,0}, {0,1}, {0,-1}}; 
    int n, m; 
    int orangesRotting(vector<vector<int>>& grid) {
        if(grid.empty() || grid[0].empty()) return -1; 
        n = grid.size(), m = grid[0].size(); 
        queue<pair<int,int>> q;
        for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            if(grid[i][j] == 2)  
                q.push({i, j});
        int res = 0;
        while(q.size()) {
            int l = q.size();
            res++;
            for(int k = 0; k < l; k++) {
                auto t = q.front();
                q.pop(); 
                int a = t.first, b = t.second; 
                for(int i = 0; i < 4; i++) {
                    int u = a + dr[i][0], v = b + dr[i][1];
                    if(u < 0 || u >= n || v < 0 || v >= m || grid[u][v] != 1) continue;
                    grid[u][v] = 2;
                    q.push({u,v});
                }
            }
           
        }
        // 如果还有橘子没有腐烂
        for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            if(grid[i][j] == 1)  return -1;
        if(res == 0) return 0;
        return res - 1;
    }      
};
```
### 53. 课程表[*****](https://leetcode.cn/problems/course-schedule/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    // 用拓扑排序，判断图中是否有环，如果有环，则无法选课
    bool canFinish(int n, vector<vector<int>>& pre) { 
        if(pre.empty() || pre[0].empty()) return true;
        vector<int> d(n + 1);
        vector<vector<int>> edges(n + 1);
        for(auto t : pre)  {
            int x = t[0], y = t[1];
            d[y]++;
            edges[x].push_back(y);
        }
        stack<int> stk;
        for(int i = 0; i < n; i++)
            if(d[i] == 0) stk.push(i);
        int cnt = 0;
        while(stk.size()) {
            auto t = stk.top();
            stk.pop();
            cnt++;
            for(auto x : edges[t]) {
                if(--d[x] == 0) stk.push(x);
            }
        }
        return cnt == n;
    }
};
```
### 54. 实现 Trie (前缀树)[*****](https://leetcode.cn/problems/implement-trie-prefix-tree/description/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Trie {
public:
    struct Node {
        Node *lson[26];
        bool is_end;
        Node(){
            for(int i = 0; i < 26; i++) lson[i] = NULL;
            is_end = false; 
        }
    }*root;
    Trie() {
        root = new Node();
    }
    
    void insert(string word) {
        Node *p = root;
        for(auto c : word) {
            int u = c - 'a';
            if(!p->lson[u]) p->lson[u] = new Node();
            p = p->lson[u];
        }
        p->is_end = true;
    }
    
    bool search(string word) {
        Node *p = root;
        for(auto c : word) {
            int u = c - 'a';
            if(!p->lson[u]) return false;
            p = p->lson[u];
        }
        return p->is_end;
    }
    
    bool startsWith(string prefix) {
        Node *p = root;
        for(auto c : prefix) {
            int u = c - 'a';
            if(!p->lson[u]) return false;
            p = p->lson[u];
        }
        return true;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```
### 52. 实现 Trie (前缀树)[*****](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)
```c++
class Trie {
public:
    // 字典树
    struct Node{
        Node *lson[26];
        bool isEnd;
        Node() {
            for(int i = 0; i < 26; i++) lson[i] = NULL;
            isEnd = false;
        }
    }*root;
    Trie() {
        root = new Node();
    }d
    
    void insert(string word) {
        Node *p = root;
        for(auto c : word) {
            int u = c - 'a';
            if(!p->lson[u]) p->lson[u] = new Node();
            p = p->lson[u];
        }
        p->isEnd = true;
    }
    
    bool search(string word) {
        Node *p = root;
        for(auto c : word) {
            char u = c - 'a';
            if(!p->lson[u]) return false;
            p = p->lson[u];
        }
        return p->isEnd == true;
    }
    
    bool startsWith(string prefix) {
        Node *p = root;
        for(auto c : prefix) {
            char u = c - 'a';
            if(!p->lson[u]) return false;
            p = p->lson[u];
        }
        return true;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
 ```
 ### 53. 全排列[***](https://leetcode.cn/problems/permutations/?envType=study-plan-v2&envId=top-100-liked)
 ```c++
 class Solution {
public:
    int n;
    vector<vector<int>> v; 
    void dfs(vector<int>& nums, int u, int state, vector<int> &res) {
        if(u == n) { 
            v.push_back(res);
            return;
        }
        for(int i = 0; i < n; i++) 
            if(!(state >> i & 1)) 
            {
                res.push_back(nums[i]);
                dfs(nums, u + 1, state | 1 << i, res);
                res.pop_back();
            }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        n = nums.size(); 
        vector<int> res;
        dfs(nums, 0, 0, res);
        return v;
    }
};
```
### 54. 子集
```c++
class Solution {
public:
    int n;
    vector<vector<int>> v;
    void dfs(vector<int>& nums, int u, int state) {
        if(u == n) {
            vector<int> res;
            for(int i = 0; i < n; i++)
                if(state >> i & 1) {
                    res.push_back(nums[i]);
                }
            v.push_back(res);
            return;
        }
        dfs(nums, u + 1, state);
        dfs(nums, u + 1, state | 1 << u); 
    }

    vector<vector<int>> subsets(vector<int>& nums) {
        n = nums.size();
        dfs(nums, 0, 0);
        return v;
    }
};
```

### 55. 电话号码的字母组合[]()
```c++
class Solution {
public:
    vector<string> v;
    string str[8] = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    void dfs(int u, string &digits, string &tmp) {
        if(u == digits.size()) {
            v.push_back(tmp);
            return;
        }
        int k = digits[u] - '2';
        for(int i = 0; i < str[k].size(); i++) { 
            tmp += str[k][i];
            dfs(u + 1, digits, tmp); 
            tmp.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if(digits.size() == 0) return v;
        string tmp;
        dfs(0, digits, tmp);
        return v;
    }
};
```     
### 56. 组合总和[***](https://leetcode-cn.com/problems/combination-sum/)
```c++
class Solution {
public:
    vector<vector<int>> v; 
    int n;
    void dfs(int u,vector<int>& candidates, int target, int sum, int start, vector<int> &res) { 
        if(sum == target) {
            v.push_back(res);
            return;
        } 
        for(int i = start; i < n && sum + candidates[i] <= target; i++)  
        { 
            res.push_back(candidates[i]);
            // 我们可以选取重复的，所以下一次start是从i开始的
            dfs(u + 1, candidates, target, sum + candidates[i], i ,res);
            res.pop_back(); 
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        n = candidates.size(); 
        // 为了避免先选大导致退出递归（而选不到小的），先排序，从小到大开始选
        sort(candidates.begin(), candidates.end());
        vector<int> res;
        dfs(0, candidates, target, 0,  0, res);
        return v;
    }
};
```
### 57. 括号生成[***](https://leetcode.cn/problems/generate-parentheses/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    vector<string> v;
    int n;
    void dfs(int lc, int rc, string res) {
        if(lc == n && rc == n) {
            v.push_back(res);
            return;
        }
        if(lc < n) dfs(lc + 1, rc, res + "(");
        if(rc < n && lc > rc) dfs(lc, rc + 1, res + ")");
    }
    vector<string> generateParenthesis(int _n) {
        n = _n;
        dfs(0, 0, "");
        return v;
    }
};
```
### 58. 单词搜索[*****](https://leetcode.cn/problems/word-search/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    int n, m;
    int dr[4][2] = {{1,0}, {-1,0}, {0,1},{0,-1}};
    vector<vector<bool>> st;
    bool dfs(vector<vector<char>>& board, int i, int j, int u, string word) {
        // if(u == word.size())  return true;
        st[i][j] = 1;
        // 用于第一次判断
        if(word[u] != board[i][j]) return false;
        if(u == word.size() - 1) return true;
        for(int k = 0; k < 4; k++) {
            int x = i + dr[k][0], y = j + dr[k][1];
            // 在这里判断 board[x][y] != word[u + 1], 是防止u无序增长
            if(x < 0 || x >= n || y < 0 || y >= m || st[x][y] ||  board[x][y] != word[u + 1]) continue;
            if(dfs(board, x, y, u + 1, word)) return true;
        }
        // 要恢复现场
        st[i][j] = 0;
        return false;
    }
    bool exist(vector<vector<char>>& board, string word) {
        if(board.empty() || board[0].empty()) return false;
        n = board.size(), m = board[0].size();
           
        for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++){
            st = vector<vector<bool>>(n + 1, vector<bool>(m + 1, 0));
            if(dfs(board, i, j, 0, word)) return true;
        }
        return false;
    }
};
```
### 59. 分割回文串[*****](https://leetcode.cn/problems/palindrome-partitioning/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    int n;
    vector<vector<string>> v;
    void dfs(int u, vector<vector<bool>> &f, string s, vector<string> &res) {
        if(u == n) {
            v.push_back(res);
            return;
        }
        for(int i = u; i < n; i++)
            if(f[u][i]) {
                string t = s.substr(u, i - u + 1);
                res.push_back(t);
                dfs(i + 1, f, s, res);
                res.pop_back();
            }
    }
    vector<vector<string>> partition(string s) {
        n = s.size();
        vector<vector<bool>> f(n + 1, vector<bool>(n + 1));
        // 先通过动态规划找到所有的回文字串
        for(int i = 0; i < n; i++)   {
            int j, k;
            for(j = i, k = i; j >= 0 && k < n; j--, k++)
                if(s[j] != s[k]) break;
                else f[j][k] = true;

            for(j = i, k = i + 1; j >= 0 && k < n; j--, k++)
              {
                  if(s[j] != s[k]) break;
                else f[j][k] = true; 
              }
        }
        cout << f[0][1] << endl;
        vector<string> res;
        // 分段回溯找到s能够分割成回文串的所有方案
        dfs(0, f, s, res);
        return v;
    }
};
```
### 60.N皇后[*****](https://leetcode.cn/problems/n-queens/)
```cpp
class Solution {
public: 
    vector<vector<string>> res;
    vector<bool> col, ag, ug;
    vector<string> path;
    int n;
    //皇后一定处于不同行，u代表行，i代表列，不能在同行同列同主副对角线
    void dfs(int u) {
        //N皇后可能存在多种情况
        if(u == n) {
            res.push_back(path);
            return;
        }
        //检查各列的情况
        for(int i = 0; i < n; i++)
            if(!col[i] && !ag[u + i] && !ug[n -i + u]) {
                col[i] = ag[u + i] = ug[n -i + u] = 1;
                path[u][i] = 'Q';
                dfs(u + 1);
                col[i] = ag[u + i] = ug[n -i + u] = 0;
                path[u][i] = '.';
            }
    }
    vector<vector<string>> solveNQueens(int _n) {
        n = _n;
        col = vector<bool>(n);
        ag = ug = vector<bool>(2*n);
        path =  vector<string> (n, string(n, '.')); 
        dfs(0);
        return res;
    }
};
```
### 61. 搜索插入位置[***](https://leetcode.cn/problems/search-insert-position/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        while(l < r) {
            int mid = l + r >> 1;
            if(nums[mid] >= target) r = mid;
            else l = mid + 1;
        }
        // 后面的位置符合
        if(nums[l] < target) return l + 1;
        return l;
    }
};
```
### 62. 搜索二维矩阵[****](https://leetcode.cn/problems/search-a-2d-matrix/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if(matrix.empty() || matrix[0].empty()) return false;
        int n = matrix.size(), m = matrix[0].size();
        int l = 0, r = n * m - 1;
        while(l < r) {
            int mid = l + r + 1 >> 1;
            if(matrix[mid / m][mid % m] <= target)  l = mid;
            else r = mid - 1;
        }
        return matrix[l / m][l % m] == target;
    }
};
```
### 63. 在排序数组中查找元素的第一个和最后一个位置
```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int n = nums.size();
        if(!n) return {-1, -1};
        int l = 0, r = n - 1;
        while(l < r) {
            int mid = l + r >> 1;
            if(nums[mid] >= target) r = mid;
            else l = mid + 1;
        }
        int x = -1, y = -1;
        if(nums[l] == target) x = l;
        l = 0, r = n - 1;
        while(l < r) {
            int mid = l + r + 1 >> 1;
            if(nums[mid] <= target) l = mid;
            else r = mid - 1;
        }
        if(nums[l] == target) y = l;
        return {x, y};
    }
};
```
### 64.搜索旋转排序数组[****](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)
``` c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        //两次二分，第一次二分找到前半段和后半段的中介点， 第二次二分找到target的位置（可能在升序，可能在降序）
        if(nums.empty()) return -1;
        int l = 0, r = nums.size() - 1;
        while(l < r) {
            //l = mid时，要+1再除以2
            int mid = l + r + 1 >> 1;
            //前半段中所有数都>nums[0]，递增的， 符合>=nums[0]条件的区间为[mid, r]，
            if(nums[mid] >= nums[0]) l = mid;
            else r = mid - 1;
        }
        //判断target在前半段还是后半段，再查找
        if(target >= nums[0]) l = 0;
        else l = l + 1, r = nums.size() -1;
        while(l < r){
            int mid = l + r >> 1; 
            if(nums[mid] >= target) r = mid;
            else l = mid + 1;
        } 
        if(nums[r] == target) return l;
        //以上使用了两个二分模板
        /*
        int bsearch_1(int l, int r)
        {
            while (l < r)
            {
                int mid = l + r >> 1;
                if (check(mid)) r = mid;
                else l = mid + 1;
            }
            return l;
        }
    int bsearch_2(int l, int r)
    {
        while (l < r)
        {
            int mid = l + r + 1 >> 1;
            if (check(mid)) l = mid;
            else r = mid - 1;
        }
        return l;
    }
    用'-'表示不满足check条件，'+'满足check条件，v表示我们的目标
    模板一：----v++++  找到满足条件的下边界
    模板二：----++++v   找到满足条件的上边界
    */
        return -1;
    }
};
```
### 65. 寻找旋转排序数组中的最小值[*****](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int n = nums.size();
        int l = 0, r = n - 1;
        while(l < r) {
            int mid = l + r + 1 >> 1;
            if(nums[mid] >= nums[0]) l = mid;
            else r = mid - 1;
        }
        if(l + 1 < n) return nums[l + 1];
        return nums[0];
    }
};
```
### 66. 寻找两个正序数组的中位数[*****](https://leetcode.cn/problems/median-of-two-sorted-arrays/description/)
``` c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) { 
        int tot = nums1.size() + nums2.size();
        if(tot % 2 == 0) {      //序列长度为偶数
            int left = find(nums1, 0, nums2, 0, tot / 2);
            int right = find(nums1, 0, nums2, 0, tot / 2 + 1);
            return (left + right) / 2.0;
        }
        else 
            return find(nums1, 0, nums2, 0, tot / 2 + 1);
    } 
    //找到nums1从i开始, nums2从j开始，第k大的元素
    int find(vector<int> &nums1, int i, vector<int> &nums2, int j, int k) {
        //nums1可用的序列长度大于nums2可用的序列长度
        if(nums1.size() - i > nums2.size() - j) return find(nums2, j, nums1, i, k);
        if(k == 1) {        //找到第一大的元素
            if(nums1.size() == i) return nums2[j];
            else    return min(nums1[i], nums2[j]);
        }
        //nums1可用序列为空
        if(nums1.size() == i) return nums2[j + k - 1];
        //si为nums1的可能到达的新位置，向右移动k/2
        int si = min((int)nums1.size(), i + k / 2), sj = j + k - k / 2;
        if(nums1[si - 1] < nums2[sj - 1])   //nums1中前k/2个元素都小于num2的第k/2位置的值，
            return find(nums1, si, nums2, j, k - (si - i));     
            //在nums1的[si,nums1.size() - 1], nums2的[j, nums2.size() - 1]的范围内找第k - (si - i)个元素
            //即等价于在nums1[i, nums1.size() - 1], nums2在[j, nums2.size() - 1]内找第K个元素
        else    
            return find(nums1, i, nums2, sj, k - (sj - j));
    }
};
```
### 67.有效的括号[**](https://leetcode.cn/problems/valid-parentheses/)
``` c++
class Solution {
public:
    bool isValid(string s) { 
        stack<char> stk;
        for(auto x : s) {
            if(x == '(' || x == '[' || x == '{')    stk.push(x);
            else {
                if(stk.size() && abs(x - stk.top()) <= 2)  stk.pop();
                else return false;
            }
        }
        return stk.size() == 0;
    }
};
```
### 68.最小栈[****](https://leetcode.cn/problems/min-stack/)
```cpp
class MinStack {
public:
    stack<int> stk, f;
    MinStack() { 
    }
    //f维护栈顶每次取出的是最小值
    void push(int val) {
        stk.push(val);
        if(!f.size() || f.top() >= val) f.push(val);
    }
    
    void pop() { 
        if(f.top() == stk.top()) f.pop();
        stk.pop();
    }
    
    int top() {
        return stk.top();
    }
    
    int getMin() {
        return f.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```
### 69. 字符串编码[**](https://leetcode.cn/problems/decode-string/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public: 
    // u要加引用，遍历完s; []里面可能还存在[]，需要递归
    string dfs(string s, int &u) {
        string res;
        while(u < s.size() && s[u] != ']') {
            // u++;
            if(s[u] >= 'a' && s[u] <= 'z' || s[u] >= 'A' && s[u] <= 'Z') res += s[u++];
            else if(s[u] >= '0' && s[u] <= '9') {
                int k = u;
                while(k < s.size() && s[k] != '[')  k++;
                int cnt = stoi(s.substr(u, k - u));
                // u指向'['
                u = k + 1;
                string y = dfs(s, u);
                // u当前指向']'
                u++;
                while(cnt--) res += y;
            }
        }
        return res;
    }
    string decodeString(string s) {
        int u = 0;
        return dfs(s, u);
    }
};
```
### 70. 每日温度[****](https://leetcode.cn/problems/daily-temperatures/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        stack<int> stk;
        vector<int> v;
        for(int i = temperatures.size() - 1; ~i; i--) {
            while(stk.size() && temperatures[stk.top()] <= temperatures[i]) stk.pop();
            if(stk.empty()) v.push_back(0);
            else v.push_back(stk.top() - i);
            stk.push(i); 
        }
        reverse(v.begin(), v.end());
        return v;
    }
};
```
### 71.柱状图中最大的矩形[*****](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)
```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& h) {
        int n = h.size();
        vector<int> left(n), right(n);
        stack<int> stk;
        //单调栈，找到左边第一个比h[i]小的位置
        for(int i = 0; i < n; i++) {
            //构建单调栈，把栈中>=h[i]的元素删除
            while(stk.size() && h[stk.top()] >= h[i]) stk.pop();
            if(stk.empty()) left[i] = -1;
            else left[i] = stk.top();
            stk.push(i);
        }
        stk = stack<int>();
        //单调栈，找到右边第一个比h[i]小的位置
        for(int i = n - 1; i >= 0; i--) {
            while(stk.size() && h[stk.top()] >= h[i]) stk.pop();
            if(stk.empty()) right[i] = n;
            else right[i] = stk.top();
            stk.push(i);
        }
        int res = 0;
        for(int i = 0; i < n; i++)  
            res = max(h[i]*(right[i] - left[i] - 1), res); 
        return res;
    }
};
``` 
### 72.数组中的第K个最大元素[****](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/)
```cpp
class Solution {
public:
    // 是从大到小找到第k个元素，因此，基准元素左边找到第一个小的，右边找到第一个大的
    int quicksort(vector<int>& nums, int l, int r, int k) {
        if(l == r) return nums[l];
        int x = nums[l], i = l - 1, j = r + 1;
        while(i < j) {
            // 找到第一个比x小的元素，++i哪怕比x大，也能往后找
            while(nums[++i] > x) ;
            // 找到第一个比x大的元素
            while(nums[--j] < x) ;
            if(i < j) swap(nums[i], nums[j]);
        } 
        // 这里要以j为界限，不能用i（i比j大1）
        // 基准元素是第j大，在左边区间查找第k大的元素
        if(k <= j) return quicksort(nums, l, j, k);
        else return quicksort(nums, j + 1, r, k);
    }
    int findKthLargest(vector<int>& nums, int k) {
        return quicksort(nums, 0, nums.size() -1, k - 1);
    }
};
```
### 73.前k个高频元素[***](https://leetcode.cn/problems/top-k-frequent-elements/description/)
```c++
// 方法一、大根堆
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 大根堆方法
        unordered_map<int,int> mp;
        for(auto x : nums) mp[x]++;
        priority_queue<pair<int,int>> heap;
        for(auto x : mp) 
        // 先比较次数
            heap.push({x.second, x.first});
        vector<int> v;
        // 出现频率前k多的
        for(int i = 0; i < k; i++) {
            v.push_back(heap.top().second);
            heap.pop();
        }
        return v;
    }
};

// 方法二、找前k个频率的阈值
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) { 
        vector<int> v;
        int n = nums.size();
        unordered_map<int,int> mp;
        for(auto x : nums) mp[x]++;
        vector<int> s(n+1);
        // 把频率出现次数存到s中
        for(auto x : mp)
            s[x.second]++;
        // 找到频率前K个的阈值
        int t = 0, i = n;
        while(t < k) t += s[i--];
        for(auto x : mp)
            if(x.second > i) 
                v.push_back(x.first);
        return v;
    }
};
```
### 74. 数据流的中位数[*****](https://leetcode.cn/problems/find-median-from-data-stream/)
```c++
class MedianFinder {
public:
    // 大根堆
    priority_queue<int> down;
    // 小根堆
    priority_queue<int, vector<int>, greater<int>> up;
    MedianFinder() {
        
    }
    时间复杂度log(n)
    void addNum(int num) {
        // 大根堆为空或者元素<=大根堆堆顶
        if(down.empty() || num <= down.top()) {
            down.push(num);
            // 大根堆个数<= 小根堆个数+1
            if(down.size() -1 > up.size()) {
                up.push(down.top());
                down.pop();
            }
        }
        else {
            up.push(num);
            // 大根堆超过小根堆时
            if(up.size() > down.size()) {
                down.push(up.top());
                up.pop();
            }
        }
    }
        // 时间复杂度o(1)
    double findMedian() {
        if(down.size() == up.size()) return (down.top() + up.top()) / 2.0;
        else return down.top();
    }
};
 

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```
### 75. 买卖股票的最佳时机[***](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int res = 0;
        for(int i = 0, tmp = INT_MAX; i < prices.size(); i++) {
            //找到所有各天股票减去前面最小值股票的那天中，找到最大值
            res = max(res, prices[i] - tmp);
            tmp = min(tmp, prices[i]);
        }
        return res;
    }
};
```
### 76.跳跃游戏[***](https://leetcode.cn/problems/jump-game/)
``` c++
class Solution {
public:
   bool canJump(vector<int>& nums) {
        for(int i = 0, j = 0;  i < nums.size(); i++) {
            // 无法跳到j处
            if(j < i) return false;
            // j代表当前i能够跳的最远距离
            j = max(j, i + nums[i]);
        }
        return true;
    }
};
```
### 77.跳跃游戏II[****](https://leetcode.cn/problems/jump-game-ii/)
``` c++
class Solution {
public:
//动态规划 + 贪心
    int jump(vector<int>& nums) {
        int n = nums.size();
        vector<int> f(n);
        int last = 0;
        f[0] = 0;
        //last -> i,  last前进的范围(i的范围)是[last, last + f[last]]
        //f[i] = f[last] + 1表示的最小跳跃次数
        for(int i = 1; i < n; i++) {
            while(i > last + nums[last]) last++;
            f[i] = f[last] + 1;
        }
        return f[n - 1];
    }
};
```
### 78. 划分字母空间[*****](https://leetcode.cn/problems/partition-labels/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    vector<int> partitionLabels(string s) {
         unordered_map<char,int> last;
         vector<int> v;
        for(int i = 0; i < s.size(); i++) last[s[i]] = i;
         int start = 0,  end = 0;
         for(int i = 0 ; i < s.size(); i++) {
            end = max(end, last[s[i]]);
            if(i == end) {
                v.push_back(end - start + 1);
                start = end = i + 1;
            }
         }
         return v;
    }
};
```
### 79.爬楼梯[***](https://leetcode.cn/problems/climbing-stairs/)
```c++
class Solution {
public:
    int climbStairs(int n) {
        //斐波拉契数列
        int a = 1, b = 1;
        //第n级阶梯需要迭代n - 1次
        for(int i = 0; i < n - 1; i++) {
            int c = a + b;
            a = b ;
            b = c;
        }
        return b;
    }
};
```
### 80. 杨辉三角[****](https://leetcode.cn/problems/pascals-triangle/description/)
```cpp
class Solution {
public:
    vector<vector<int>> generate(int n) {
        vector<vector<int>> f(n); 
        for(int i = 0; i < n; i++)  {
            f[i].resize(i + 1);
            f[i][0] = f[i][i] = 1; 
            for(int j = 1; j < i; j++) {
                f[i][j] = f[i - 1][j] + f[i - 1][j - 1]; 
            }
        }
        return f;
    }
};
```
### 81.打家劫舍[****](https://leetcode.cn/problems/house-robber/description/)
```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        vector<int> f(n + 1), g(n + 1);
        //f[i]在1~i中必选第i个
        //g[i]在1~i中不选第i个
        for(int i = 1; i <= n; i++) {
            //不能取相邻的现金，所以不能选i-1位置的现金
            f[i] = g[i - 1] + nums[i - 1];
            g[i] = max(f[i - 1], g[i - 1]);
        }
        return max(f[n], g[n]);
    }
};
```
### 82.完全平方数[*****](https://leetcode.cn/problems/perfect-squares/)
```c++
class Solution {
public:
    //背包问题
    int numSquares(int n) { 
        vector<int> f(n + 1, 1e9);
        f[0] = 0;
        for(int i = 1; i <= n / i; i++) {
            int w = i * i;
            for(int j = w; j <= n; j++)
                f[j] = min(f[j], f[j - w] + 1);
        }
        return f[n];
    }
};
```
### 83.零钱兑换[****](https://leetcode.cn/problems/coin-change/)
```c++
class Solution {
public:
// 硬币个数无限，计算amount金额的最少个数，f[j]是硬币个数, j表示金额
    int coinChange(vector<int>& coins, int amount) {
        vector<int>f(amount + 1, 1e9);
        // 金额为0，硬币个数为0
        f[0] = 0; 
        for(int i = 0; i < coins.size(); i++)
        for(int j = coins[i]; j <= amount; j++)
            f[j] = min(f[j], f[j - coins[i]] + 1);
        if(f[amount] == 1e9) return -1;
        return f[amount];
    }
};
```
### 84. 单词划分[****](https://leetcode.cn/problems/word-break/description/)
```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        typedef unsigned long long ULL;   //64位
        const int P = 131;
        //使用ULL和P来查找字符串，快速将字符串转化为唯一的整数
        unordered_set<ULL> hash;
        for(auto &word : wordDict) {
            ULL h = 0;
            for(auto c : word) h = h * P + c;
            hash.insert(h);
        }
        int n = s.size();
        vector<int> f(n + 1);
        //f[i]表示1~i的字符可以被分成wordDict中的字符串
        f[0] = true;
        s = ' ' + s;
        for(int i = 0; i < n; i++) 
            if(f[i]) {
                ULL h = 0;
                //1~i符合，i+1~j也符合，则1~j也能有wordDict字符串组成
                for(int j = i + 1; j <= n; j++) {
                    h = h * P + s[j];
                    if(hash.count(h)) f[j] = true;
                }
            }
        return f[n];
    }
};
```
### 85.最长递增子序列[*****](https://leetcode.cn/problems/longest-increasing-subsequence/description/)
```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> f(n, 0);
        int res = 0;
        //动态规划找最长上升子序列，时间复杂度O(n*n)
        for(int i = 0; i < n; i++) { 
            f[i] = 1;
            for(int j = 0; j < i; j++)
                if(nums[j] < nums[i]) 
                    f[i] = max(f[i], f[j] + 1);
            res = max(res, f[i]);
        }
    
        return res;
    }
};
```
```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        //构造单调队列q,希望单调队列尽可能长，则要让单调队列上升尽可能慢
        vector<int> q;
        for(auto x : nums) {
            if(q.empty() || q.back() < x) q.push_back(x);
            else {
                int l = 0, r = q.size() - 1;
                while(l < r) {
                    int mid = l + r >> 1;
                    //在单调队列中找到第一个>=x的位置，然后替换
                    if(q[mid] >= x) r = mid;
                    else l = mid + 1;
                }
                q[l] = x;
            }
        }
        return q.size();
    }
};
```
### 86.乘积最大子数组[****](https://leetcode.cn/problems/maximum-product-subarray/description/)
```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int f = nums[0], g = nums[0], res = nums[0];
        for(int i = 1; i < nums.size(); i++) {
            int a = nums[i], fa = f * a, ga = g * a;  
            // a > 0当前最大值为fa， a<0当前最大值为ga， a=0，最大值为0
            //最小值同理
            f = max(a, max(fa, ga));
            g = min(a, min(fa, ga));
            res = max(res, f);
        }
        return res;
    }
};
```
### 87. 分割等和子集[****](https://leetcode.cn/problems/partition-equal-subset-sum/description/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(auto x : nums) sum += x;
        if(sum % 2 == 1) return false;
        int m = sum /2, n = nums.size();
        vector<int> f(m +  1, false);
        f[0] = true;
        for(int i = 0; i < n; i++)
        for(int j = m; j >= nums[i]; j--)
            f[j] |= f[j - nums[i]];
        return f[m];
    }
};
```
### 88.最长有效括号[*****](https://leetcode.cn/problems/longest-valid-parentheses/description/)
``` c++
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> stk;
        int res = 0;
        //把s分为各段，每段满足总的左括号的数量比右括号数量小1，但是段内(除去最后一个右括号)左括号的数量>=右括号，有效括号一定在段内，不可能跨段
        for(int i = 0, start = -1; i < s.size(); i++) {
            //start作为段的前一个位置  ，     左括号入栈
            if(s[i] == '(') stk.push(i);
            else {
                //有匹配的左括号，必定拥有有效的括号序列
                if(stk.size()) {
                    stk.pop();
                    //退掉匹配的左括号后，栈中仍然有左括号，那么栈顶可作为匹配序列最左端的前一个位置
                    if(stk.size()) {
                        res = max(res, i - stk.top());
                    }
                    //栈中没有元素，那么整段都是有效的括号序列
                    else 
                        res = max(res, i - start);
                }
                //没有与之匹配的左括号，说明到达段的末尾，可以作为下一个段的左端前一个位置start
                else 
                    start = i;
            }
        }
        return res;
    }
};
```
### 89.不同路径[****](https://leetcode.cn/problems/unique-paths/description/)
```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
       vector<vector<int>> f(m + 1, vector<int>(n + 1));
        f[0][0] = 1;
        for(int i = 0; i < m; i++)
        for(int j = 0;  j < n; j++)
        {
            if(!i) f[i][j] = 1;
            else if(!j) f[i][j] = 1;
            else f[i][j] = f[i - 1][j] + f[i][j - 1];
        }
        return f[m - 1][n - 1];
    }
};
```
### 90.最小路径和[***](https://leetcode.cn/problems/minimum-path-sum/description/)
```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        if(grid.empty() || grid[0].empty()) return 0;
        int n = grid.size(), m = grid[0].size();
        vector<vector<int>> f(n + 1, vector<int> (m + 1, INT_MAX));
        f[0][0] = 0;
        for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++) { 
            if(i == 1 && j == 1) f[i][j] = grid[0][0];
            else 
                f[i][j] = min(f[i - 1][j], f[i][j - 1]) + grid[i - 1][j - 1]; 
        }
        return f[n][m];
    }
};
```
### 91.最长回文子串[***](https://leetcode.cn/problems/longest-palindromic-substring/description/)
``` c++
class Solution {
public:
    string longestPalindrome(string s) {
        string res;
        for(int i = 0; i < s.size(); i++) {
            //回文串为偶数长度
            int l = i - 1, r = i + 1;
            while(l >= 0 && r < s.size() && s[l] == s[r]) l--, r++;     
            if(res.size() < r - l - 1) res = s.substr(l + 1, r - l - 1);    //从 l+1位开始，长度为r-l-1的字串
            //回文串为奇数长度
            l = i, r = i + 1;
            while(l >= 0 && r < s.size() && s[l] == s[r]) l--, r++;
            if(res.size() < r - l - 1) res = s.substr(l + 1, r - l - 1);
        }
        return res;
    }
};
```
### 92. 最长公共子序列[****](https://leetcode.cn/problems/longest-common-subsequence/?envType=study-plan-v2&envId=top-100-liked)
```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        // f[i][j] = f[i - 1][j], f[i][j - 1]
        int n = text1.size(), m = text2.size();
        vector<vector<int>> f(n + 1, vector<int> (m + 1));
        for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            if(text1[i - 1] == text2[j - 1]) f[i][j] = f[i - 1][j - 1] + 1;
            else 
                f[i][j] = max(f[i - 1][j], f[i][j - 1]);
        return f[n][m];
    }
};
```
### 93.编辑距离[***](https://leetcode.cn/problems/edit-distance/description/)
```cpp
class Solution {
public:
    int minDistance(string a, string b) { 
        int n = a.size(), m = b.size();
        a = " " + a;
        b = " " + b;
        // f[i][j]表示将A[1~i]变成B[1~j]的按顺序最小操作次数
        vector<vector<int>> f(n + 1, vector<int>(m + 1));
        //将a的前i个变成0个，需要i步
        for(int i = 0; i <= n; i++) f[i][0] = i;
        for(int j = 0; j <= m; j++) f[0][j] = j;
        //f[i][j]是a的前i个变成b的前j个
        for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++) {
            //删除或插入, f[i-1][j]删除a中第i个或者b中插入第j+1个, f[i][j-1]:插入a中第i+1个或者b中删除第j个
            f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1;
            //如果a[i] == b[j]，则不需要修改，否则要修改一次
            int t = a[i] != b[j];
            f[i][j] = min(f[i][j], f[i - 1][j - 1] + t);
        }
        return f[n][m];
    }
};
```

### 94. 只出现一次的数字[***](https://leetcode.cn/problems/single-number/description/?envType=study-plan-v2&envId=top-100-liked)
```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for(auto x : nums)  {
            res ^= x;
        }
        return res;
    }
};
```
### 95.多数元素[****](https://leetcode.cn/problems/majority-element/)
```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        //r是当前的数，c是r的库存
        int r = 0, c = 0;
        //因为总有某数超过1半，那么最后输出的r一定是该数
        for(auto x : nums) {
            //库存为0，放入r，库存增1
            if(!c) r = x, c = 1;
            //和库存的数不相等，则库存减一
            else if(x != r) c--;
            else c++;
        }
        return r;
    }
};
```
### 96.颜色分类[***](https://leetcode.cn/problems/sort-colors/description/)
```c++
//三指针
class Solution {
public:
    void sortColors(vector<int>& nums) {
        // 0 ~ j-1表示的是0，  j ~ i-1表示的是1,   k+1 ~ nums.size()-1表示的是2
        for(int i = 0, j = 0, k = nums.size() - 1; i <= k;) {
            if(nums[i] == 0) {
                swap(nums[i], nums[j]);
                i++, j++;
            }
            else if(nums[i] == 2) {
                swap(nums[i], nums[k]);
                k--;
            }
            else i++;
        }
    }
};
```
### 97.下一个排列[***](https://leetcode.cn/problems/next-permutation/description/)
``` c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int k = nums.size() - 1;
        //从右往左找到降序的第一个数nums[k - 1]
        while(k > 0 && nums[k - 1] >= nums[k]) k--;
        if(k <= 0) {
            reverse(nums.begin(), nums.end());
        }
        else {
            int t = k;
            //从k~nums.size()之间找到第一个比nums[k - 1]大的数，两者交换，k-1右边再进行排序，就是字典序下一个数
            while(t < nums.size() && nums[t] > nums[k - 1]) t++;
            swap(nums[k - 1], nums[t - 1]);
            reverse(nums.begin() + k , nums.end());
        }
    }
};
```
### 98. 寻找重复数[****](https://leetcode.cn/problems/find-the-duplicate-number/description/)
```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        //环的入口就是重复的数，0是起点，入口会被索引两次
        int a = 0, b = 0;
        while(true) {
            a = nums[a];
            b = nums[nums[b]];
            if(a == b) {
                a = 0;
                while(a != b) {
                    a = nums[a];
                    b = nums[b];
                }
                return a;
            }
        }
        return -1;
    }
};
```
### 99.合并区间[***](https://leetcode.cn/problems/merge-intervals/description/)
``` c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        //满足两个原则即可合并成功，
        //1. 按照区间左边界排序 2. 如果两个区间有交集，则前面区间的右边界大于后面区间的左边界
        vector<vector<int>> res;
        sort(intervals.begin(), intervals.end());
        int l = intervals[0][0], r = intervals[0][1];
        for(int i = 1; i < intervals.size(); i++) {
            // 无交集
            if(intervals[i][0] > r) {
                res.push_back({l, r});
                l = intervals[i][0], r = intervals[i][1];
            }
            else 
            // 有交集
                r = max(r, intervals[i][1]);
        }
        res.push_back({l, r});
        return res;
    }
};
```
### 100.最大子数组和[***](https://leetcode.cn/problems/maximum-subarray/)
```c++
//动态规划
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        //f[i]表示所有以nums[i]结尾的区间中的最大值
        //f[i] = max{nums[i], f[i - 1] + nums[i]}
        //     = nums[i] + max(f[i - 1], 0)
        int res = INT_MIN, last = 0;
        for(int i = 0; i < nums.size(); i++) {
            last = nums[i] + max(0, last);
            res = max(res, last);
        }
        return res;
    }
};

//分治法
class Solution {
public:
    struct Node{
        int sum, s, ls, rs; //总和，总的最大和，最大前缀，最大后缀
    };
    Node build(vector<int>& nums, int l, int r) {
        
        if(l == r) {
            int v = max(nums[l], 0);
            return {nums[l], v, v, v};
        }
        int mid = l + r >> 1;
        Node L = build(nums, l, mid), R = build(nums, mid + 1, r);
        Node res;
        res.sum = L.sum + R.sum;
        //总的最大和是左区间最大和，右区间最大和，左区间的最大后缀+右区间的最大前缀 的最大值
        res.s = max(max(L.s, R.s), L.rs + R.ls);
        //总的最大前缀是左区间最大前缀，左区间和+右区间最大前缀 的最大值
        res.ls = max(L.ls, L.sum + R.ls);
        //总的最大后缀是右区间最大后缀，右区间和+左区间最大前后缀 的最大值
        res.rs = max(R.rs, R.sum + L.rs);
        return res;
    }
    int maxSubArray(vector<int>& nums) { 
        int res = INT_MIN;
        for(auto x: nums) res = max(res, x);
        if(res < 0) return res;
        Node t = build(nums, 0, nums.size() - 1);
        return t.s; 
    }
};
``` 