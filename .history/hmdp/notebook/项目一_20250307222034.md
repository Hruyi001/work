# 1. 两级登录拦截器 + ThreadLocal
### 1.1 两级登录拦截器
#### 1.1.1 一级拦截器(对所有请求进行拦截处理)
1. 用户请求携带token，从中获取到token
2. 以token作为key到缓存中查询用户的登录信息，如果缓存没命中，就到mysql库中查询
3. 将用户信息保存到ThreadLocal中（如果用户未登录，ThreadLocal中保存的是一个空对象）
4. 刷新token的有效期
5. 放行请求，交给二级拦截器
#### 1.1.2 二级拦截器（除了登录页面、验证码页面，首页不拦截，拦截处理需要登录的页面）
1. 从ThreadLocal中获取用户信息
2. 如果用户信息为空，说明用户未登录，进行拦截；否则，放行
### 1.2 ThreadLocal 
[见javaguide的ThreadLocal讲解](https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#%E5%A6%82%E4%BD%95%E8%B7%A8%E7%BA%BF%E7%A8%8B%E4%BC%A0%E9%80%92-threadlocal-%E7%9A%84%E5%80%BC)

# 2. Cannal实现缓存和数据库最终一致性
1. ​**问题定位：​** 双写一致的核心挑战是数据库与缓存的原子性缺失，Canal 通过异步监听 Binlog 解决这一问题。  
2. ​**技术实现：​**  
   - Canal 监听数据库变更 → 自动调用 Redis API 更新缓存。  
   - 使用 Redis 事务保证缓存操作的原子性，结合重试机制应对失败。  
3. ​**优势：​**  
   - 异步解耦，不阻塞主业务；  
   - 无需 MQ，架构更轻量；  
   - 生产级稳定性（源于 Alibaba 开源项目）。  
4. ​**风险控制：​**  
   - 通过 Canal 集群和 Binlog 持久化保障数据不丢；  
   - 业务ID去重 + 监控告警兜底异常场景。
 ---
### **第一段：问题定位与方案设计**
  
### **1. 监听数据库变更**  
通过 Canal 监听 MySQL Binlog，实时捕获商铺数据的增删改操作（如库存、价格变更），实现数据库与缓存的异步解耦。  

---

### **2. 解析事件并驱动缓存更新**  
根据 Binlog 事件类型（INSERT/UPDATE/DELETE），自动将变更数据同步到 Redis 缓存，无需业务代码显式调用缓存 API。  

---

### **3. 使用Redis事务保障原子性**  
对缓存更新操作包裹在 Redis `MULTI/EXEC` 事务中，确保缓存与数据库操作的原子性，避免部分写入异常。  

---

### **4. 幂等性处理防重复**  
通过业务唯一ID（如商品ID）去重，防止同一变更事件被多次处理导致缓存数据冗余。  

---

### **5. 高可用设计防丢失**  
部署 Canal 集群并通过 ZooKeeper 管理节点，同时配置 MySQL Binlog 持久化，确保数据不因服务宕机或网络故障丢失。  

---

### **6. 对比MQ方案更轻量**  
无需引入消息队列，直接通过 Canal 内置能力驱动缓存更新，架构更简单且延迟更低，适合对实时性要求高的场景。  

--- 

### **核心优势总结**  
• **异步解耦**：主业务无阻塞，性能提升明显。  
• **最终一致性**：通过 Binlog 顺序监听和缓存事务，保证数据最终一致。  
• **运维可控**：基于开源项目（Canal）和成熟组件（Redis），降低实施风险。

---
 
 #
 